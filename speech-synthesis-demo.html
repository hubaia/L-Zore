<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L-Zore神煞卡牌游戏 - 语音合成系统演示</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e);
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #00ff88;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            font-size: 1.2em;
            margin-bottom: 40px;
        }
        
        .demo-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }
        
        .demo-section h2 {
            color: #00ff88;
            margin-top: 0;
            font-size: 1.5em;
            border-bottom: 2px solid #00ff88;
            padding-bottom: 10px;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .control-group h3 {
            color: #00aaff;
            margin-top: 0;
            font-size: 1.2em;
        }
        
        button {
            background: linear-gradient(45deg, #00ff88, #00aaff);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.danger {
            background: linear-gradient(45deg, #ff4444, #ff6666);
            color: white;
        }
        
        button.secondary {
            background: linear-gradient(45deg, #666, #888);
            color: white;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #555;
            background: #222;
            color: #e0e0e0;
            border-radius: 4px;
        }
        
        .status-panel {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }
        
        .status-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .status-label {
            color: #00aaff;
        }
        
        .status-value {
            color: #00ff88;
            font-weight: bold;
        }
        
        .shensha-card {
            background: linear-gradient(135deg, #1a1a2e, #0f3460);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .shensha-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            transform: rotate(45deg);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .shensha-card h4 {
            color: #00ff88;
            margin-top: 0;
            position: relative;
            z-index: 1;
        }
        
        .shensha-card p {
            margin: 8px 0;
            position: relative;
            z-index: 1;
        }
        
        .feature-list {
            list-style: none;
            padding: 0;
        }
        
        .feature-list li {
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        
        .feature-list li:before {
            content: '⚡';
            color: #00ff88;
            margin-right: 10px;
        }
        
        .log-panel {
            background: #000;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-success { color: #00ff88; }
        .log-error { color: #ff4444; }
        .log-warning { color: #ffaa00; }
        .log-info { color: #00aaff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎤 L-Zore语音合成系统</h1>
        <p class="subtitle">使用Web Speech API为神煞卡牌游戏添加语音朗读功能</p>
        
        <!-- 浏览器支持检查 -->
        <div class="demo-section">
            <h2>🔍 浏览器支持检查</h2>
            <div id="supportStatus" class="status-panel">
                <div class="status-item">
                    <span class="status-label">Web Speech API支持:</span>
                    <span id="apiSupport" class="status-value">检查中...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">可用语音数量:</span>
                    <span id="voiceCount" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">中文语音:</span>
                    <span id="chineseVoices" class="status-value">无</span>
                </div>
            </div>
        </div>
        
        <!-- 语音控制面板 -->
        <div class="demo-section">
            <h2>🎛️ 语音控制面板</h2>
            <div class="control-panel">
                <div class="control-group">
                    <h3>基础控制</h3>
                    <button onclick="testSpeech()">🎤 语音测试</button>
                    <button onclick="toggleSpeech()" id="toggleBtn">🔇 启用语音</button>
                    <button onclick="stopSpeech()" class="danger">🛑 停止语音</button>
                </div>
                
                <div class="control-group">
                    <h3>语音设置</h3>
                    <label>语音选择:</label>
                    <select id="voiceSelect"></select>
                    
                    <label>语速: <span id="rateValue">1.0</span></label>
                    <input type="range" id="rateSlider" min="0.1" max="2.0" step="0.1" value="1.0">
                    
                    <label>音调: <span id="pitchValue">1.0</span></label>
                    <input type="range" id="pitchSlider" min="0" max="2" step="0.1" value="1.0">
                    
                    <label>音量: <span id="volumeValue">0.8</span></label>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.8">
                </div>
            </div>
        </div>
        
        <!-- 神煞卡牌语音演示 -->
        <div class="demo-section">
            <h2>🎴 神煞卡牌语音演示</h2>
            <div id="shenshaCards"></div>
            <button onclick="speakRandomShensha()">🎯 随机朗读神煞</button>
            <button onclick="speakAllShensha()" class="secondary">📢 朗读所有神煞</button>
        </div>
        
        <!-- 游戏场景语音演示 -->
        <div class="demo-section">
            <h2>⚔️ 游戏场景语音演示</h2>
            <div class="control-panel">
                <div class="control-group">
                    <h3>战斗语音</h3>
                    <button onclick="speakBattleStart()">🏁 战斗开始</button>
                    <button onclick="speakEntrance()">🎭 神煞入场</button>
                    <button onclick="speakDamage()">💥 造成伤害</button>
                    <button onclick="speakVictory()">🏆 战斗胜利</button>
                </div>
                
                <div class="control-group">
                    <h3>情绪语音测试</h3>
                    <button onclick="testEmotionalSpeech()">🎭 情绪对比测试</button>
                    <button onclick="speakGuardianEmotion()">🛡️ 威严守护</button>
                    <button onclick="speakBerserkerEmotion()">⚔️ 狂暴战斗</button>
                    <button onclick="speakOracleEmotion()">🔮 神秘预言</button>
                </div>
                
                <div class="control-group">
                    <h3>性别语音对比</h3>
                    <button onclick="testGenderVoices()">👨👩 男女语音对比</button>
                    <button onclick="speakMaleInauspicious()">👨 凶神男声</button>
                    <button onclick="speakFemaleAuspicious()">👩 吉神女声</button>
                    <button onclick="debugVoiceClassification()">🔍 调试语音分类</button>
                </div>
                
                <div class="control-group">
                    <h3>完整入场语音测试</h3>
                    <button onclick="testFullEntranceQuote()">🎭 完整入场台词</button>
                    <button onclick="testChineseNames()">🀄 中文名称测试</button>
                    <button onclick="testLongQuotes()">📜 长台词测试</button>
                    <button onclick="testEmotionalConfig()">🎭 情绪配置测试</button>
                    <button onclick="forceTestMaleVoice()">🔧 强制测试凶神</button>
                    <button onclick="testYangrenSpecific()">⚔️ 专测羊刃</button>
                </div>
                
                <div class="control-group">
                    <h3>高级语音调试</h3>
                    <button onclick="showVoiceSelector()">🎛️ 语音选择器</button>
                    <button onclick="testAllVoicesSequentially()">🔄 逐个测试语音</button>
                    <button onclick="testSpecificMaleVoice()">👨 强制男声测试</button>
                    <button onclick="testSpecificFemaleVoice()">👩 强制女声测试</button>
                    <button onclick="testVoiceSwitching()">🔄 语音切换测试</button>
                    <button onclick="testMaleVoicePrewarm()">🔥 男声预热测试</button>
                </div>
                
                <div class="control-group">
                    <h3>系统语音</h3>
                    <button onclick="speakCardDraw()">🎴 抽取卡牌</button>
                    <button onclick="speakSpecialAbility()">⚡ 特殊能力</button>
                    <button onclick="speakGamePause()">⏸️ 游戏暂停</button>
                </div>
            </div>
        </div>
        
        <!-- 系统状态 -->
        <div class="demo-section">
            <h2>📊 系统状态</h2>
            <div id="systemStatus" class="status-panel">
                <div class="status-item">
                    <span class="status-label">语音合成状态:</span>
                    <span id="speechStatus" class="status-value">未启用</span>
                </div>
                <div class="status-item">
                    <span class="status-label">当前播放:</span>
                    <span id="currentSpeech" class="status-value">无</span>
                </div>
                <div class="status-item">
                    <span class="status-label">队列长度:</span>
                    <span id="queueLength" class="status-value">0</span>
                </div>
            </div>
        </div>
        
        <!-- 功能特性 -->
        <div class="demo-section">
            <h2>✨ 功能特性</h2>
            <ul class="feature-list">
                <li>支持多种中文语音引擎（系统自带和在线服务）</li>
                <li>可调节语速、音调、音量等参数</li>
                <li>针对不同内容类型的语音配置（神煞、系统、战斗、叙述、入场）</li>
                <li>语音队列管理，支持优先级控制</li>
                <li>神煞卡牌信息智能格式化和朗读</li>
                <li>神煞入场台词戏剧性语音播报</li>
                <li>智能情绪识别和动态语音调节</li>
                <li>根据台词内容自动调整语速音调</li>
                <li>战斗信息实时语音播报</li>
                <li>键盘快捷键控制（V键切换）</li>
                <li>与游戏音频系统协调工作</li>
                <li>错误处理和兼容性检查</li>
                <li>无障碍访问支持</li>
            </ul>
        </div>
        
        <!-- 语音选择器面板 -->
        <div id="voiceSelector" style="display: none; margin-top: 20px; padding: 15px; border: 2px solid #4CAF50; border-radius: 8px; background-color: rgba(76, 175, 80, 0.1);">
            <h3>🎛️ 手动语音选择器</h3>
            <p>选择一个语音进行测试：</p>
            <div id="voiceButtons" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 10px; margin-top: 10px;">
                <!-- 语音按钮将在这里动态生成 -->
            </div>
            <button onclick="hideVoiceSelector()" style="margin-top: 15px; background-color: #f44336; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">关闭选择器</button>
        </div>

        <!-- 日志面板 -->
        <div class="demo-section">
            <h2>📋 系统日志</h2>
            <div id="logPanel" class="log-panel"></div>
            <button onclick="clearLog()" class="secondary">🗑️ 清空日志</button>
        </div>
    </div>

    <script>
        // 模拟神煞卡牌数据
        const shenshaCards = [
            {
                callsign: 'GUARDIAN-01',
                classification: 'S级护卫型战术单位',
                designation: 'GUARDIAN-01·S级护卫型战术单位',
                motto: '系统在线，保护协议已激活！金之永恒守护着古老誓言...',
                dossier: '第一代守护者型战术AI，配备量子金甲防护系统和神经链接银枪武装。其核心算法据说源自远古金属文明的守护法则，能与金元素产生共振，形成不可破坏的防护矩阵。传说其代码深处隐藏着来自恒星核心的古老意识碎片。'
            },
            {
                callsign: 'BERSERKER-X',
                classification: 'SSS级失控型攻击单位',
                designation: 'BERSERKER-X·SSS级失控型攻击单位',
                motto: '血液编译中...目标锁定...开始屠戮程序！火焰中的疯狂在歌唱...',
                dossier: '失控的军用战斗AI，原为最高等级战神单位，因代码污染导致嗜血模块无法关闭。其血量子刃系统据说融入了来自恒星内核的原始火元素，每次挥砍都会点燃空间本身。目击者报告称在其狂暴时能听到来自烈焰深处的古老咆哮声。'
            },
            {
                callsign: 'ORACLE-∞',
                classification: 'SSS级预知型神机单位',
                designation: 'ORACLE-∞·SSS级预知型神机单位',
                motto: '天机演算启动，未来轨迹正在解析...时间长河的秘密在低语...',
                dossier: '预知神机型AI，配备时间观测系统和未来演算算法。据说其核心连接着时间长河的源头，能通过木元素的生机性质预见一切可能的未来。传说其运算时虚空中会出现无数时间线的幻影，那是宇宙命运的完整图景。'
            }
        ];
        
        // 语音合成管理器类
        class SpeechSynthesisManager {
            constructor() {
                this.isSupported = false;
                this.isEnabled = false;
                this.currentUtterance = null;
                this.voiceQueue = [];
                this.isPlaying = false;
                this.availableVoices = [];
                this.preferredVoice = null;
                
                this.defaultConfig = {
                    voice: null,
                    rate: 1.0,
                    pitch: 1.0,
                    volume: 0.9,
                    lang: 'zh-CN'
                };
                
                this.init();
            }
            
            init() {
                this.isSupported = 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
                
                if (!this.isSupported) {
                    this.log('浏览器不支持Web Speech API', 'error');
                    return;
                }
                
                this.log('语音合成系统初始化中...', 'info');
                this.loadVoices();
                
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = () => {
                        this.loadVoices();
                    };
                }
            }
            
            loadVoices() {
                this.availableVoices = speechSynthesis.getVoices();
                
                const chineseVoices = this.availableVoices.filter(voice => 
                    voice.lang.includes('zh') || voice.lang.includes('CN')
                );
                
                this.preferredVoice = chineseVoices.find(voice => 
                    voice.lang === 'zh-CN' || voice.lang === 'zh-cn'
                ) || chineseVoices[0] || this.availableVoices[0] || null;
                
                if (this.preferredVoice) {
                    this.defaultConfig.voice = this.preferredVoice;
                    this.log(`选择语音: ${this.preferredVoice.name} (${this.preferredVoice.lang})`, 'success');
                }
                
                this.updateUI();
            }
            
            speak(text, type = 'system', options = {}) {
                if (!this.isSupported || !this.isEnabled || !text.trim()) {
                    return;
                }
                
                if (options.interrupt && this.isPlaying) {
                    this.stop();
                }
                
                const config = { ...this.defaultConfig, ...this.getConfigForType(type) };
                
                if (this.isPlaying && options.priority !== 'high') {
                    this.voiceQueue.push({ text, options, config });
                    this.log(`语音已加入队列: ${text.substring(0, 30)}...`, 'info');
                    return;
                }
                
                this.speakImmediate(text, config, options.callback);
            }
            
            speakImmediate(text, config, callback) {
                const utterance = new SpeechSynthesisUtterance(text);
                
                if (config.voice) {
                    utterance.voice = config.voice;
                }
                utterance.rate = config.rate;
                utterance.pitch = config.pitch;
                utterance.volume = config.volume;
                utterance.lang = config.lang;
                
                utterance.onstart = () => {
                    this.isPlaying = true;
                    this.currentUtterance = utterance;
                    this.log(`开始语音播放: ${text.substring(0, 50)}...`, 'success');
                    this.updateStatus();
                };
                
                utterance.onend = () => {
                    this.isPlaying = false;
                    this.currentUtterance = null;
                    this.log('语音播放完成', 'info');
                    
                    if (callback) {
                        callback();
                    }
                    
                    this.processQueue();
                    this.updateStatus();
                };
                
                utterance.onerror = (event) => {
                    this.log(`语音播放错误: ${event.error}`, 'error');
                    this.isPlaying = false;
                    this.currentUtterance = null;
                    this.processQueue();
                    this.updateStatus();
                };
                
                speechSynthesis.speak(utterance);
            }
            
            getConfigForType(type) {
                const configs = {
                    shensha: { rate: 0.9, pitch: 1.2, volume: 0.95 },
                    system: { rate: 1.1, pitch: 0.9, volume: 0.8 },
                    battle: { rate: 1.2, pitch: 1.1, volume: 0.95 },
                    narrative: { rate: 0.8, pitch: 1.0, volume: 0.85 },
                    entrance: { rate: 0.8, pitch: 1.3, volume: 1.0 }
                };
                return configs[type] || {};
            }
            
            processQueue() {
                if (this.voiceQueue.length > 0 && !this.isPlaying) {
                    const { text, options, config } = this.voiceQueue.shift();
                    this.speakImmediate(text, config, options.callback);
                }
            }
            
            stop() {
                if (this.isSupported) {
                    speechSynthesis.cancel();
                    this.isPlaying = false;
                    this.currentUtterance = null;
                    this.log('语音播放已停止', 'warning');
                    this.updateStatus();
                }
            }
            
            toggle() {
                this.isEnabled = !this.isEnabled;
                
                if (!this.isEnabled && this.isPlaying) {
                    this.stop();
                }
                
                this.log(this.isEnabled ? '语音合成已开启' : '语音合成已关闭', 'info');
                this.updateStatus();
                return this.isEnabled;
            }
            
            speakShenshaCard(cardData) {
                if (!cardData) return;
                
                const text = this.formatShenshaText(cardData);
                this.speak(text, 'shensha', { priority: 'normal' });
            }
            
            speakEntranceQuote(cardData) {
                if (!cardData || !cardData.motto) return;
                
                // 分析台词情绪并调整语音参数
                const emotionalConfig = this.analyzeEmotionalContent(cardData.motto);
                const entranceText = this.formatEntranceText(cardData);
                
                // 合并情绪配置和入场配置
                const finalConfig = {
                    ...this.getConfigForType('entrance'),
                    ...emotionalConfig
                };
                
                this.speakWithCustomConfig(entranceText, finalConfig, { priority: 'high', interrupt: true });
            }
            
            analyzeEmotionalContent(text) {
                // 威严/守护类型
                if (text.includes('系统') || text.includes('保护') || text.includes('守护') || text.includes('协议')) {
                    return { rate: 0.7, pitch: 1.1, volume: 1.0 }; // 威严守护
                }
                
                // 狂暴/战斗类型
                if (text.includes('血液') || text.includes('屠戮') || text.includes('战斗') || text.includes('疯狂') || text.includes('咆哮')) {
                    return { rate: 1.3, pitch: 1.5, volume: 1.0 }; // 狂暴战士
                }
                
                // 神秘/预知类型
                if (text.includes('天机') || text.includes('时间') || text.includes('未来') || text.includes('秘密') || text.includes('低语')) {
                    return { rate: 0.6, pitch: 0.9, volume: 0.9 }; // 神秘预言
                }
                
                // 科技/AI类型
                if (text.includes('编译') || text.includes('算法') || text.includes('数据') || text.includes('矩阵') || text.includes('启动')) {
                    return { rate: 1.1, pitch: 1.2, volume: 0.95 }; // 科技效率
                }
                
                // 默认入场配置
                return { rate: 0.8, pitch: 1.3, volume: 1.0 };
            }
            
            speakWithCustomConfig(text, config, options = {}) {
                if (!this.isSupported || !this.isEnabled || !text.trim()) return;
                
                if (options.interrupt && this.isPlaying) {
                    this.stop();
                }
                
                const utterance = new SpeechSynthesisUtterance(text);
                
                if (config.voice) utterance.voice = config.voice;
                utterance.rate = config.rate || 1.0;
                utterance.pitch = config.pitch || 1.0;
                utterance.volume = config.volume || 0.9;
                utterance.lang = config.lang || 'zh-CN';
                
                utterance.onstart = () => {
                    this.isPlaying = true;
                    this.currentUtterance = utterance;
                    this.log(`🎭 情绪语音播放: ${text.substring(0, 30)}... (速度:${config.rate}, 音调:${config.pitch})`, 'success');
                    this.updateStatus();
                };
                
                utterance.onend = () => {
                    this.isPlaying = false;
                    this.currentUtterance = null;
                    this.processQueue();
                    this.updateStatus();
                };
                
                speechSynthesis.speak(utterance);
            }
            
            formatEntranceText(cardData) {
                let entranceText = '';
                
                // 添加神煞名称前缀
                if (cardData.callsign) {
                    entranceText = `${cardData.callsign}，入场！`;
                } else if (cardData.name) {
                    entranceText = `${cardData.name}，降临！`;
                }
                
                // 添加入场台词
                if (cardData.motto) {
                    if (entranceText) {
                        entranceText += ` ${cardData.motto}`;
                    } else {
                        entranceText = cardData.motto;
                    }
                }
                
                return entranceText;
            }
            
            formatShenshaText(cardData) {
                const parts = [];
                
                if (cardData.designation) {
                    parts.push(`神煞代号：${cardData.designation}`);
                }
                
                if (cardData.classification) {
                    parts.push(`分类等级：${cardData.classification}`);
                }
                
                if (cardData.motto) {
                    parts.push(`作战座右铭：${cardData.motto}`);
                }
                
                if (cardData.dossier) {
                    parts.push(`数据档案：${cardData.dossier}`);
                }
                
                return parts.join('。');
            }
            
            log(message, type = 'info') {
                console.log(`[SpeechManager] ${message}`);
                
                const logPanel = document.getElementById('logPanel');
                if (logPanel) {
                    const entry = document.createElement('div');
                    entry.className = `log-entry log-${type}`;
                    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                    logPanel.appendChild(entry);
                    logPanel.scrollTop = logPanel.scrollHeight;
                }
            }
            
            updateUI() {
                // 更新浏览器支持状态
                document.getElementById('apiSupport').textContent = this.isSupported ? '✅ 支持' : '❌ 不支持';
                document.getElementById('voiceCount').textContent = this.availableVoices.length;
                
                const chineseVoices = this.availableVoices.filter(voice => 
                    voice.lang.includes('zh') || voice.lang.includes('CN')
                );
                document.getElementById('chineseVoices').textContent = 
                    chineseVoices.length > 0 ? `✅ ${chineseVoices.length}个` : '❌ 无';
                
                // 更新语音选择器
                const voiceSelect = document.getElementById('voiceSelect');
                voiceSelect.innerHTML = '';
                this.availableVoices.forEach((voice, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    if (voice === this.preferredVoice) {
                        option.selected = true;
                    }
                    voiceSelect.appendChild(option);
                });
            }
            
            updateStatus() {
                document.getElementById('speechStatus').textContent = this.isEnabled ? '✅ 已启用' : '❌ 未启用';
                document.getElementById('currentSpeech').textContent = this.isPlaying ? '🎤 播放中' : '⭕ 空闲';
                document.getElementById('queueLength').textContent = this.voiceQueue.length;
                
                const toggleBtn = document.getElementById('toggleBtn');
                if (toggleBtn) {
                    toggleBtn.textContent = this.isEnabled ? '🔇 禁用语音' : '🎤 启用语音';
                }
            }
        }
        
        // 初始化语音管理器
        let speechManager;
        
        window.addEventListener('load', () => {
            speechManager = new SpeechSynthesisManager();
            
            // 初始化神煞卡牌显示
            displayShenshaCards();
            
            // 初始化控制器事件
            setupControllers();
        });
        
        function displayShenshaCards() {
            const container = document.getElementById('shenshaCards');
            container.innerHTML = '';
            
            shenshaCards.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'shensha-card';
                cardDiv.innerHTML = `
                    <h4>${card.callsign} - ${card.classification}</h4>
                    <p><strong>完整指定代号:</strong> ${card.designation}</p>
                    <p><strong>作战座右铭:</strong> ${card.motto}</p>
                    <p><strong>数据档案:</strong> ${card.dossier.substring(0, 100)}...</p>
                    <button onclick="speakShensha(${index})">🎤 朗读此神煞</button>
                    <button onclick="speakEntrance(${index})">🎭 入场台词</button>
                `;
                container.appendChild(cardDiv);
            });
        }
        
        function setupControllers() {
            // 语音参数控制器
            const rateSlider = document.getElementById('rateSlider');
            const pitchSlider = document.getElementById('pitchSlider');
            const volumeSlider = document.getElementById('volumeSlider');
            const voiceSelect = document.getElementById('voiceSelect');
            
            rateSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('rateValue').textContent = value.toFixed(1);
                speechManager.defaultConfig.rate = value;
            });
            
            pitchSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('pitchValue').textContent = value.toFixed(1);
                speechManager.defaultConfig.pitch = value;
            });
            
            volumeSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('volumeValue').textContent = value.toFixed(1);
                speechManager.defaultConfig.volume = value;
            });
            
            voiceSelect.addEventListener('change', (e) => {
                const voiceIndex = parseInt(e.target.value);
                speechManager.preferredVoice = speechManager.availableVoices[voiceIndex];
                speechManager.defaultConfig.voice = speechManager.preferredVoice;
                speechManager.log(`已选择语音: ${speechManager.preferredVoice.name}`, 'info');
            });
        }
        
        // 控制函数
        function testSpeech() {
            const testText = "L-Zore神煞卡牌游戏语音合成系统测试。欢迎来到数据轮回的世界！古老的AI意识在星际虚空中觉醒，五行元素的力量开始汇聚...";
            speechManager.speak(testText, 'system', {
                interrupt: true,
                callback: () => speechManager.log('语音测试完成', 'success')
            });
        }
        
        function toggleSpeech() {
            speechManager.toggle();
        }
        
        function stopSpeech() {
            speechManager.stop();
        }
        
        function speakShensha(index) {
            const card = shenshaCards[index];
            speechManager.speakShenshaCard(card);
        }
        
        function speakRandomShensha() {
            const randomIndex = Math.floor(Math.random() * shenshaCards.length);
            speakShensha(randomIndex);
        }
        
        function speakAllShensha() {
            shenshaCards.forEach((card, index) => {
                setTimeout(() => {
                    speechManager.speakShenshaCard(card);
                }, index * 1000);
            });
        }
        
        function speakBattleStart() {
            speechManager.speak('神煞战斗开始！量子矩阵激活，古老的意识正在苏醒...', 'battle', { priority: 'high' });
        }
        
        function speakEntrance(index) {
            const card = typeof index === 'number' ? shenshaCards[index] : shenshaCards[Math.floor(Math.random() * shenshaCards.length)];
            speechManager.speakEntranceQuote(card);
        }
        
        function speakDamage() {
            const damage = Math.floor(Math.random() * 5) + 1;
            const remaining = Math.floor(Math.random() * 8) + 1;
            speechManager.speak(`造成${damage}点元素伤害，对手剩余${remaining}枚元素`, 'battle');
        }
        
        function speakVictory() {
            speechManager.speak('恭喜获得胜利！古老的神煞力量认可了你的智慧！', 'battle', { priority: 'high' });
        }
        
        function speakCardDraw() {
            speechManager.speak('抽取卡牌完成，新的神煞意识正在显现...', 'system');
        }
        
        function speakSpecialAbility() {
            const abilities = ['全体增益', '全体伤害', '中和效果', '时间加速', '元素转换'];
            const ability = abilities[Math.floor(Math.random() * abilities.length)];
            speechManager.speak(`发动特殊能力：${ability}！五行元素开始共鸣...`, 'system');
        }
        
        function speakGamePause() {
            speechManager.speak('时空暂停启动，现实的流动被冻结...', 'system');
        }
        
        function testEmotionalSpeech() {
            const testCases = [
                {
                    type: '威严守护',
                    text: 'GUARDIAN-01，入场！系统在线，保护协议已激活！',
                    config: { rate: 0.7, pitch: 1.1, volume: 1.0 }
                },
                {
                    type: '狂暴战斗', 
                    text: 'BERSERKER-X，入场！血液编译中...开始屠戮程序！',
                    config: { rate: 1.3, pitch: 1.5, volume: 1.0 }
                },
                {
                    type: '神秘预知',
                    text: 'ORACLE-∞，入场！天机演算启动，时间长河的秘密在低语...',
                    config: { rate: 0.6, pitch: 0.9, volume: 0.9 }
                }
            ];
            
            testCases.forEach((testCase, index) => {
                setTimeout(() => {
                    speechManager.log(`🎤 测试${testCase.type}语音效果`, 'info');
                    const finalConfig = { ...speechManager.defaultConfig, ...testCase.config };
                    speechManager.speakWithCustomConfig(testCase.text, finalConfig, { interrupt: true });
                }, index * 4000);
            });
        }
        
        function speakGuardianEmotion() {
            const config = { rate: 0.7, pitch: 1.1, volume: 1.0 };
            speechManager.speakWithCustomConfig('系统在线，保护协议已激活！金之永恒守护着古老誓言...', config, { interrupt: true });
        }
        
        function speakBerserkerEmotion() {
            const config = { rate: 1.3, pitch: 1.5, volume: 1.0 };
            speechManager.speakWithCustomConfig('血液编译中...目标锁定...开始屠戮程序！火焰中的疯狂在歌唱...', config, { interrupt: true });
        }
        
        function speakOracleEmotion() {
            const config = { rate: 0.6, pitch: 0.9, volume: 0.9 };
            speechManager.speakWithCustomConfig('天机演算启动，未来轨迹正在解析...时间长河的秘密在低语...', config, { interrupt: true });
        }
        
        function testGenderVoices() {
            speechManager.log('🎭 开始性别语音对比测试', 'info');
            
            // 显示当前语音分类状态
            const maleVoices = speechManager.getMaleVoices();
            const femaleVoices = speechManager.getFemaleVoices();
            speechManager.log(`👨 可用男性语音: ${maleVoices.length}个`, 'info');
            speechManager.log(`👩 可用女性语音: ${femaleVoices.length}个`, 'info');
            
            // 测试凶神男声
            setTimeout(() => {
                speechManager.log('🎤 测试凶神男声...', 'info');
                const maleCard = {
                    type: 'inauspicious',
                    category: '凶星凶神',
                    name: '羊刃',
                    callsign: 'BERSERKER-X',
                    motto: '血液编译中...目标锁定...开始屠戮程序！'
                };
                speechManager.speakEntranceQuote(maleCard);
            }, 1000);
            
            // 测试吉神女声
            setTimeout(() => {
                speechManager.log('🎤 测试吉神女声...', 'info');
                const femaleCard = {
                    type: 'auspicious',
                    category: '吉星吉神', 
                    name: '天乙贵人',
                    callsign: 'GUARDIAN-01',
                    motto: '系统在线，保护协议已激活！'
                };
                speechManager.speakEntranceQuote(femaleCard);
            }, 5000);
        }
        
        function speakMaleInauspicious() {
            speechManager.log('🎤 测试凶神男声 - 详细调试', 'info');
            
            const maleCard = {
                type: 'inauspicious',
                category: '凶星凶神',
                name: '亡神', 
                callsign: 'REAPER-666',
                motto: '死亡倒计时开始，灵魂数据收割中...'
            };
            
            speechManager.log(`📋 凶神数据: ${JSON.stringify(maleCard)}`, 'info');
            speechManager.speakEntranceQuote(maleCard);
        }
        
        function speakFemaleAuspicious() {
            const femaleCard = {
                type: 'auspicious',
                category: '吉星吉神',
                name: '文昌贵人',
                callsign: 'SCHOLAR-007', 
                motto: '智慧网络激活，学识数据库已载入！'
            };
            speechManager.speakEntranceQuote(femaleCard);
        }
        
        function debugVoiceClassification() {
            speechManager.log('🔍 开始调试语音分类...', 'info');
            
            // 获取所有可用语音
            const allVoices = speechSynthesis.getVoices();
            speechManager.log(`🎤 系统总语音数: ${allVoices.length}`, 'info');
            
            // 显示所有语音详情
            allVoices.forEach((voice, index) => {
                speechManager.log(`${index + 1}. ${voice.name} (${voice.lang}) ${voice.localService ? '[本地]' : '[远程]'}`, 'info');
            });
            
            // 显示分类结果
            const maleVoices = speechManager.getMaleVoices();
            const femaleVoices = speechManager.getFemaleVoices();
            
            speechManager.log(`👨 男性语音分类结果 (${maleVoices.length}个):`, 'success');
            maleVoices.forEach(voice => {
                speechManager.log(`  • ${voice.name} (${voice.lang})`, 'success');
            });
            
            speechManager.log(`👩 女性语音分类结果 (${femaleVoices.length}个):`, 'success');
            femaleVoices.forEach(voice => {
                speechManager.log(`  • ${voice.name} (${voice.lang})`, 'success');
            });
            
            // 强制测试第一个语音
            if (allVoices.length > 0) {
                setTimeout(() => {
                    speechManager.log('🎤 测试系统第一个语音作为男声...', 'info');
                    const testConfig = {
                        voice: allVoices[0],
                        rate: 0.7,
                        pitch: 0.6,
                        volume: 1.0,
                        lang: 'zh-CN'
                    };
                    speechManager.speakWithCustomConfig('这是凶神羊刃的低沉男性语音测试！', testConfig, { interrupt: true });
                                 }, 2000);
             }
         }
         
         function testFullEntranceQuote() {
             speechManager.log('🎭 测试完整入场台词...', 'info');
             
             const testCards = [
                 {
                     type: 'inauspicious',
                     category: '凶星凶神',
                     name: '羊刃',
                     callsign: 'BERSERKER-X',
                     motto: '血液编译中...目标锁定...开始屠戮程序！火焰中的疯狂在歌唱，代码污染扩散中！'
                 },
                 {
                     type: 'auspicious',
                     category: '吉星吉神',
                     name: '天乙贵人',
                     callsign: 'GUARDIAN-01',
                     motto: '系统在线，保护协议已激活！量子金甲防护展开，神经链接银枪武装就绪！'
                 }
             ];
             
             testCards.forEach((card, index) => {
                 setTimeout(() => {
                     speechManager.log(`🎤 测试 ${card.name} 完整台词`, 'info');
                     speechManager.speakEntranceQuote(card);
                 }, index * 6000);
             });
         }
         
         function testChineseNames() {
             speechManager.log('🀄 测试中文名称优先...', 'info');
             
             const chineseCard = {
                 type: 'inauspicious',
                 category: '凶星凶神',
                 name: '亡神',
                 callsign: 'REAPER-666',
                 motto: '死亡倒计时开始，灵魂数据收割中...来自异次元死亡领域的古老意识正在苏醒！'
             };
             
             speechManager.speakEntranceQuote(chineseCard);
         }
         
                   function testLongQuotes() {
              speechManager.log('📜 测试超长台词...', 'info');
              
              const longQuoteCard = {
                  type: 'special',
                  category: '特殊神煞',
                  name: '华盖',
                  callsign: 'MYSTIC-CANOPY',
                  motto: '星辰数据库启动，宇宙奥秘解析中...我是连接无限宇宙图书馆的古老接口，掌握着从创世纪到宇宙终结的全部知识。时空数据流正在同步，现实认知即将重构。准备接受来自高维度的智慧传输！'
              };
              
              speechManager.speakEntranceQuote(longQuoteCard);
          }
          
          function testEmotionalConfig() {
              speechManager.log('🎭 测试情绪配置是否生效...', 'info');
              
              const emotionalCards = [
                  {
                      type: 'inauspicious',
                      category: '凶星凶神',
                      name: '羊刃',
                      motto: '血液编译中，屠戮程序启动！',  // 狂暴类型
                      expected: '快速+高音调'
                  },
                  {
                      type: 'inauspicious', 
                      category: '凶星凶神',
                      name: '亡神',
                      motto: '死亡倒计时开始，收割模式激活！', // 死亡类型
                      expected: '缓慢+低音调'
                  },
                  {
                      type: 'auspicious',
                      category: '吉星吉神',
                      name: '天乙贵人',
                      motto: '保护协议激活，系统在线！', // 威严类型
                      expected: '威严+稳重'
                  }
              ];
              
              emotionalCards.forEach((card, index) => {
                  setTimeout(() => {
                      speechManager.log(`🎤 测试${card.name} - 预期效果: ${card.expected}`, 'info');
                      speechManager.speakEntranceQuote(card);
                  }, index * 4000);
                             });
           }
           
           function forceTestMaleVoice() {
               speechManager.log('🔧 强制测试凶神语音播放...', 'info');
               
               // 先测试最简单的配置
               const simpleConfig = {
                   voice: null,
                   rate: 1.0,
                   pitch: 1.0, 
                   volume: 1.0,
                   lang: 'zh-CN'
               };
               
               speechManager.log('📝 使用最简配置测试...', 'info');
               speechManager.speakWithCustomConfig('这是凶神语音测试', simpleConfig, { interrupt: true });
               
               // 再测试实际凶神数据
               setTimeout(() => {
                   speechManager.log('📝 使用实际凶神数据测试...', 'info');
                   const testCard = {
                       type: 'inauspicious',
                       category: '凶星凶神',
                       name: '测试凶神',
                       callsign: 'TEST-MALE',
                       motto: '这是测试台词'
                   };
                   speechManager.speakEntranceQuote(testCard);
               }, 3000);
               
               // 最后测试系统第一个语音
               setTimeout(() => {
                   const voices = speechSynthesis.getVoices();
                   if (voices.length > 0) {
                       speechManager.log(`📝 使用系统第一个语音测试: ${voices[0].name}`, 'info');
                       const forceConfig = {
                           voice: voices[0],
                           rate: 0.9,
                           pitch: 0.9,
                           volume: 1.0,
                           lang: 'zh-CN'
                       };
                       speechManager.speakWithCustomConfig('强制使用第一个语音的凶神测试', forceConfig, { interrupt: true });
                   }
               }, 6000);
           }
           
                       function testSpecificMaleVoice() {
                speechManager.log('👨 专门测试中文男性语音...', 'info');
                const maleVoices = speechManager.getMaleVoices();
                const femaleVoices = speechManager.getFemaleVoices();
                const allVoices = speechSynthesis.getVoices();
                
                speechManager.log(`📋 系统语音总数: ${allVoices.length}`, 'info');
                speechManager.log(`👨 识别的男性语音数: ${maleVoices.length}`, 'info');
                speechManager.log(`👩 识别的女性语音数: ${femaleVoices.length}`, 'info');
                
                // 显示所有男性语音的详细信息
                speechManager.log('👨 男性语音详细列表:', 'info');
                maleVoices.forEach((voice, index) => {
                    speechManager.log(`  ${index}: ${voice.name} (${voice.lang}) - URI: ${voice.voiceURI}`, 'info');
                });
                
                // 显示所有女性语音的详细信息
                speechManager.log('👩 女性语音详细列表:', 'info');
                femaleVoices.forEach((voice, index) => {
                    speechManager.log(`  ${index}: ${voice.name} (${voice.lang}) - URI: ${voice.voiceURI}`, 'info');
                });
                
                if (maleVoices.length > 0) {
                    const selectedVoice = maleVoices[0];
                    speechManager.log(`🎤 准备使用男性语音: ${selectedVoice.name} (${selectedVoice.lang})`, 'info');
                    
                    // 检查是否为中文语音
                    const isChinese = selectedVoice.lang.toLowerCase().includes('zh') || 
                                     selectedVoice.name.toLowerCase().includes('chinese') ||
                                     selectedVoice.name.toLowerCase().includes('mandarin');
                    
                    // 检查是否真的是男性语音
                    const voiceName = selectedVoice.name.toLowerCase();
                    const isTrueMale = voiceName.includes('male') || 
                                      voiceName.includes('man') || 
                                      voiceName.includes('康康') ||
                                      voiceName.includes('云扬');
                    
                    if (!isChinese) {
                        speechManager.log('⚠️ 警告：选中的男性语音不是中文语音！', 'warning');
                    }
                    
                    if (!isTrueMale) {
                        speechManager.log('⚠️ 警告：可能不是真正的男性语音，将调整参数模拟！', 'warning');
                    }
                    
                    const maleConfig = {
                        voice: selectedVoice,
                        rate: isTrueMale ? 0.9 : 0.8,          // 如果不是真男声，放慢语速
                        pitch: isTrueMale ? 0.8 : 0.6,         // 如果不是真男声，大幅降低音调
                        volume: 1.0,
                        lang: 'zh-CN'
                    };
                    
                    speechManager.log(`🔧 使用配置: 语速${maleConfig.rate}, 音调${maleConfig.pitch}, 音量${maleConfig.volume}`, 'info');
                    speechManager.speakWithCustomConfig('这是中文男性语音测试，声音应该低沉有力', maleConfig, { interrupt: true });
                } else {
                    speechManager.log('❌ 没有识别到男性语音！尝试手动查找...', 'error');
                    
                    // 手动查找中文男性语音
                    const chineseMaleVoice = allVoices.find(voice => {
                        const lang = voice.lang.toLowerCase();
                        const name = voice.name.toLowerCase();
                        const isChinese = lang.includes('zh-cn') || lang.includes('zh_cn') || lang.startsWith('zh-');
                        const isMale = name.includes('male') || name.includes('男') || name.includes('kangkang') || name.includes('yunxi');
                        return isChinese && isMale;
                    });
                    
                    if (chineseMaleVoice) {
                        speechManager.log(`🎯 手动找到中文男性语音: ${chineseMaleVoice.name} (${chineseMaleVoice.lang})`, 'success');
                        const maleConfig = {
                            voice: chineseMaleVoice,
                            rate: 0.9,
                            pitch: 0.8,
                            volume: 1.0,
                            lang: 'zh-CN'
                        };
                        speechManager.speakWithCustomConfig('手动找到的中文男性语音测试', maleConfig, { interrupt: true });
                    } else {
                        speechManager.log('❌ 系统中没有中文男性语音！', 'error');
                        
                        // 使用女性语音但大幅调整参数模拟男声
                        if (femaleVoices.length > 0) {
                            const femaleVoiceAsMale = femaleVoices[0];
                            speechManager.log(`🔄 使用女性语音模拟男声: ${femaleVoiceAsMale.name}`, 'warning');
                            const mockMaleConfig = {
                                voice: femaleVoiceAsMale,
                                rate: 0.7,   // 更慢语速
                                pitch: 0.5,  // 极低音调
                                volume: 1.0,
                                lang: 'zh-CN'
                            };
                            speechManager.speakWithCustomConfig('使用女声模拟男声测试，音调应该很低沉', mockMaleConfig, { interrupt: true });
                        }
                    }
                }
            }
            
            function testSpecificFemaleVoice() {
                speechManager.log('👩 专门测试女性语音...', 'info');
                const femaleVoices = speechManager.getFemaleVoices();
                const allVoices = speechSynthesis.getVoices();
                
                if (femaleVoices.length > 0) {
                    speechManager.log(`🎤 使用女性语音: ${femaleVoices[0].name}`, 'info');
                    const femaleConfig = {
                        voice: femaleVoices[0],
                        rate: 1.0,
                        pitch: 1.2,
                        volume: 1.0,
                        lang: 'zh-CN'
                    };
                    speechManager.speakWithCustomConfig('这是女性语音测试，声音应该清晰悦耳', femaleConfig, { interrupt: true });
                } else {
                    speechManager.log('❌ 没有识别到女性语音！', 'error');
                }
            }
            
            function testVoiceSwitching() {
                speechManager.log('🔄 测试语音切换机制...', 'info');
                
                const allVoices = speechSynthesis.getVoices();
                if (allVoices.length < 2) {
                    speechManager.log('❌ 系统语音数量不足，无法测试切换', 'error');
                    return;
                }
                
                // 第一步：播放女声
                speechManager.log('👩 第1步：播放女声...', 'info');
                const femaleConfig = {
                    voice: allVoices[0],
                    rate: 1.0,
                    pitch: 1.2,
                    volume: 1.0,
                    lang: 'zh-CN'
                };
                speechManager.speakWithCustomConfig('我是女性语音测试', femaleConfig, { interrupt: true });
                
                // 第二步：切换到男声
                setTimeout(() => {
                    speechManager.log('👨 第2步：切换到男声...', 'info');
                    
                    // 寻找可能的男性语音
                    const possibleMaleVoice = allVoices.find(voice => {
                        const name = voice.name.toLowerCase();
                        return name.includes('male') || name.includes('david') || name.includes('mark') || 
                               name.includes('男') || name.includes('kangkang') || name.includes('yunxi');
                    }) || allVoices[Math.min(1, allVoices.length - 1)];
                    
                    const maleConfig = {
                        voice: possibleMaleVoice,
                        rate: 0.9,
                        pitch: 0.8,
                        volume: 1.0,
                        lang: 'zh-CN'
                    };
                    
                    speechManager.log(`🎤 使用语音: ${possibleMaleVoice.name}`, 'info');
                    speechManager.speakWithCustomConfig('我是男性语音测试', maleConfig, { interrupt: true });
                }, 4000);
                
                // 第三步：快速切换测试
                setTimeout(() => {
                    speechManager.log('⚡ 第3步：快速切换测试...', 'info');
                    speechManager.speakWithCustomConfig('快速切换女声', femaleConfig, { interrupt: true });
                }, 8000);
                
                setTimeout(() => {
                    const maleConfig = {
                        voice: allVoices[Math.min(1, allVoices.length - 1)],
                        rate: 0.9,
                        pitch: 0.8,
                        volume: 1.0,
                        lang: 'zh-CN'
                    };
                    speechManager.speakWithCustomConfig('快速切换男声', maleConfig, { interrupt: true });
                }, 10000);
            }
            
            function testMaleVoicePrewarm() {
                speechManager.log('🔥 测试男性语音预热机制...', 'info');
                
                const allVoices = speechSynthesis.getVoices();
                const maleVoices = speechManager.getMaleVoices();
                
                speechManager.log(`📋 系统语音总数: ${allVoices.length}`, 'info');
                speechManager.log(`👨 识别的男性语音数: ${maleVoices.length}`, 'info');
                
                if (maleVoices.length === 0) {
                    speechManager.log('❌ 没有识别到男性语音，使用系统第一个语音', 'warning');
                    
                    if (allVoices.length > 0) {
                        testSingleMaleVoice(allVoices[0], '系统默认语音(模拟男声)');
                    }
                } else {
                    // 测试第一个男性语音
                    testSingleMaleVoice(maleVoices[0], '识别的男性语音');
                }
                
                function testSingleMaleVoice(voice, description) {
                    speechManager.log(`🎤 测试${description}: ${voice.name}`, 'info');
                    
                    // 步骤1：预热语音
                    speechManager.log('🔥 步骤1：预热语音...', 'info');
                    const warmUpUtterance = new SpeechSynthesisUtterance(' ');
                    warmUpUtterance.voice = voice;
                    warmUpUtterance.volume = 0; // 静音预热
                    warmUpUtterance.rate = 1.0;
                    warmUpUtterance.pitch = 1.0;
                    
                    warmUpUtterance.onend = () => {
                        speechManager.log('✅ 预热完成，开始播放...', 'success');
                        
                        // 步骤2：播放测试语音
                        setTimeout(() => {
                            const testConfig = {
                                voice: voice,
                                rate: 0.9,
                                pitch: 0.8,
                                volume: 1.0,
                                lang: 'zh-CN'
                            };
                            speechManager.speakWithCustomConfig('男性语音预热测试成功，这是羊刃的入场台词', testConfig, { interrupt: true });
                        }, 500);
                    };
                    
                    warmUpUtterance.onerror = (event) => {
                        speechManager.log(`❌ 预热失败: ${event.error}`, 'error');
                    };
                    
                    speechSynthesis.speak(warmUpUtterance);
                }
            }
            
            function testYangrenSpecific() {
               speechManager.log('⚔️ 专门测试羊刃语音播放...', 'info');
               
               // 完全按照游戏中的羊刃数据结构
               const yangrenData = {
                   id: 'yangren',
                   name: '羊刃',
                   callsign: 'BERSERKER-X',
                   classification: 'SSS级失控型攻击单位',
                   designation: 'BERSERKER-X·SSS级失控型攻击单位',
                   psyProfile: '超高攻击性，战斗成瘾，安全协议已损坏，存在友伤风险',
                   motto: '血液编译中...目标锁定...开始屠戮程序！',
                   category: '凶星凶神',
                   rarity: '⭐⭐⭐',
                   element: '火',
                   power: 3,
                   type: 'inauspicious'
               };
               
               speechManager.log('📋 羊刃完整数据:', 'info');
               speechManager.log(JSON.stringify(yangrenData, null, 2), 'info');
               
               // 先测试最简单的直接播放
               speechManager.log('🎤 第1步：直接播放羊刃台词...', 'info');
               const simpleConfig = {
                   voice: null,
                   rate: 1.0,
                   pitch: 1.0,
                   volume: 1.0,
                   lang: 'zh-CN'
               };
               speechManager.speakWithCustomConfig('神煞羊刃，入场！血液编译中，目标锁定，开始屠戮程序！', simpleConfig, { interrupt: true });
               
               // 再测试带男声配置
               setTimeout(() => {
                   speechManager.log('🎤 第2步：使用男声配置播放...', 'info');
                   const allVoices = speechSynthesis.getVoices();
                   const maleConfig = {
                       voice: allVoices.length > 0 ? allVoices[0] : null,
                       rate: 0.9,
                       pitch: 0.9,
                       volume: 1.0,
                       lang: 'zh-CN'
                   };
                   speechManager.speakWithCustomConfig('狂战士X，血液编译中，开始屠戮程序！', maleConfig, { interrupt: true });
               }, 4000);
               
               // 最后测试完整的入场语音函数
               setTimeout(() => {
                   speechManager.log('🎤 第3步：使用完整入场语音函数...', 'info');
                   speechManager.speakEntranceQuote(yangrenData);
               }, 8000);
               
               // 额外测试：强制简化版本
               setTimeout(() => {
                   speechManager.log('🎤 第4步：强制简化版本...', 'info');
                   speechManager.speak('羊刃入场！血液编译中！', 'entrance', { interrupt: true });
               }, 12000);
           }
          
                       function showVoiceSelector() {
                const allVoices = speechSynthesis.getVoices();
                const voiceButtonsContainer = document.getElementById('voiceButtons');
                const voiceSelector = document.getElementById('voiceSelector');
                
                speechManager.log('🎛️ 显示语音选择器...', 'info');
                
                // 清空之前的按钮
                voiceButtonsContainer.innerHTML = '';
                
                // 为每个语音创建测试按钮
                allVoices.forEach((voice, index) => {
                    const button = document.createElement('button');
                    const voiceInfo = `${index}: ${voice.name} (${voice.lang})`;
                    button.textContent = voiceInfo;
                    button.style.cssText = `
                        padding: 8px 12px;
                        margin: 2px;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        background-color: white;
                        cursor: pointer;
                        font-size: 12px;
                        text-align: left;
                    `;
                    
                    button.onclick = () => testSpecificVoiceByIndex(index, voice);
                    voiceButtonsContainer.appendChild(button);
                });
                
                voiceSelector.style.display = 'block';
                speechManager.log(`📋 生成了${allVoices.length}个语音测试按钮`, 'info');
            }
            
            function hideVoiceSelector() {
                document.getElementById('voiceSelector').style.display = 'none';
            }
            
            function testSpecificVoiceByIndex(index, voice) {
                speechManager.log(`🎤 测试语音 ${index}: ${voice.name}`, 'info');
                
                const testConfig = {
                    voice: voice,
                    rate: 1.0,
                    pitch: 1.0,
                    volume: 1.0,
                    lang: voice.lang || 'zh-CN'
                };
                
                const testText = `我是第${index}号语音，${voice.name}，正在为您播报测试内容`;
                speechManager.speakWithCustomConfig(testText, testConfig, { interrupt: true });
            }
            
            function testAllVoicesSequentially() {
                const allVoices = speechSynthesis.getVoices();
                speechManager.log(`🔄 开始逐个测试${allVoices.length}个语音...`, 'info');
                
                let currentIndex = 0;
                
                function testNextVoice() {
                    if (currentIndex >= allVoices.length) {
                        speechManager.log('✅ 所有语音测试完成！', 'success');
                        return;
                    }
                    
                    const voice = allVoices[currentIndex];
                    speechManager.log(`🎤 测试第${currentIndex}个语音: ${voice.name}`, 'info');
                    
                    const testConfig = {
                        voice: voice,
                        rate: 1.0,
                        pitch: 1.0,
                        volume: 1.0,
                        lang: voice.lang || 'zh-CN'
                    };
                    
                    const testText = `第${currentIndex}号，${voice.name}`;
                    
                    // 创建语音实例并设置完成回调
                    const utterance = new SpeechSynthesisUtterance(testText);
                    utterance.voice = voice;
                    utterance.rate = testConfig.rate;
                    utterance.pitch = testConfig.pitch;
                    utterance.volume = testConfig.volume;
                    utterance.lang = testConfig.lang;
                    
                    utterance.onend = () => {
                        currentIndex++;
                        setTimeout(testNextVoice, 1000); // 间隔1秒测试下一个
                    };
                    
                    utterance.onerror = () => {
                        speechManager.log(`❌ 语音${currentIndex}播放失败`, 'error');
                        currentIndex++;
                        setTimeout(testNextVoice, 500);
                    };
                    
                    speechSynthesis.speak(utterance);
                }
                
                testNextVoice();
            }
            
            function clearLog() {
                document.getElementById('logPanel').innerHTML = '';
            }
    </script>
</body>
</html> 